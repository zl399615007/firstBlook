<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script>

    //本质区别：基本数据类型是按照值来操作的，引用数据类型操作的是对内存空间的引用地址


    //1.js是运行在浏览器中的客户端脚本编程语言，当浏览器加载HTML页面的时候，首先会提供一个供js代码执行的环境，我们把它称为“全局作用域”（window/global)

    var obj={};
    //首先开辟一个新的内存空间，然后浏览器为其开辟一个16进制的地址，假设为xxxfff000
    //把对象种的属性名和属性值分别的存储到xxxfff000这个空间中
    //定义一个变量obj，然后把xxxfff000这个地址值赋给obj，此时obj存储的是一个虚拟的内存地址


    //2.函数数据类型：函数定义，函数执行
    //把函数体中的代码当作字符串存储到对应的内存空间
    function fn(){
        var total=null;
        for(var i=0;i<arguments.length;i++){
            var cur=Number(arguments[i]);
            if(!isNaN(cur)){
                total+=cur;
            }
        }
        return total;
    }
    //fn-->只是代表当前函数本身
    //fn()-->让当前函数执行

    //fn();
    //->函数执行的时候，目的是为了让定义的时候存储的那些代码字符串变为真正的代码取执行
    //->当函数执行的时候，首先会形成一个私有的作用域，来供函数体中的js代码执行，来保护里面的私有变量不受外界的干扰，我们把函数的这种保护机制叫做“闭包”

    //3.js中的内存分类
    //-->栈内存：（作用域-->全局作用域和私有作用域） 提供js代码执行的环境，并且存储基本数据类型值
    //-->堆内存：存储引用数据类行值的一个空间，例如：对于对象数据类型存储的是属性名和属性值，对于函数数据类行存储的是代码字符串...


    //4.闭包
    //当函数执行的时候会形成一个私有的作用域来保护里面的私有变量不受外界的干扰我们把函数的这种保护机制叫做“闭包”



    //预解释（变量提升）
    //在当前的作用域中，js代码从上到下执行之前，浏览器会默认的先把所有带var/function关键字的进行提前的声明或者定义
    //->声明：告诉浏览器在当前的作用域中有一个名字叫num->var num;只声明没有定义的话默认的值是undefined
    //->定义：给变量赋值->num=13;

    //在预解释中阶段，带var关键字的只是提前的声明，只有在js中从上到下执行的过程中才会进行定义赋值
    //在预解释中阶段，带function关键字的声明加定义两部分都完成了

    //1.预解释只发生在当前作用域

    //2.当函数执行的时候形成一个新的私有作用域，它会按照如下的步骤一步步的执行：
    //->1）首先给形参赋值
    //->2）私有作用域中的预解释：把私有作用域中带var和function关键字的进行提前的声明或者定义
    //->3）私有作用域中的代码从上到下执行


    //3.作用域链
    //-->在私有作用域中，js代码从上到下执行，如果遇到一个变量
    //1)首先看是否是自己私有的变量，如果是私有的，则接下来的所有操作（获取值，修改值。。。）都是用自己私有的，和外面的没有任何的关系
    //2)如果不是自己私有的，则去当前作用域的上一级作用域中查找，如果上一级有，那么接下来操作的，都是在操作上级作用域中的变量，如果上级也没有，则继续向上查找，一直找到window为止；
    //3)如果找到window还没有，如果是 变量=值，相当于给window下增加一个属性名和属性值；如果是 console.log(变量） 获取值，则会报错

    //4.如何看变量是否为私有的
    //->首先看是否为形参
    //->然后看是否在私有作用域中声明过（看有没有带var)
    //两者有其一，就是私有的变量；如果两个都不是，就不是私有的，按照作用域链的原理查找


    //in:检测当前某个属性名是否属于这个对象，如果属于返回true,不属于返回false
    //在全局作用域中我们声明的全局变量也相当于是window的一个属性名

    //预解释无节操：
    //1.不管条件是否成立，里面出现的所有带var/function关键字的都要进行预解释


    //函数表达式：把一个函数定义的部分当作一个值赋给一个变量或者一个元素的某个事件
    //2.“=”是赋值，等号左边的是变量，右边是常量（值），所以在预解释的时候，只对左边的变量进行预解释，右边的是不进行预解释的

    //3.在私有作用域中，虽然return下面代码不会再执行了，但是会进行预解释。return后面是返回给函数外面的值，所以不进行预解释
    //函数体中return下面的代码都不在执行了

    //在全局作用域下声明的变量或者函数都是相当于给window增加了一个属性名，例如：var fn-->window.fn  function fn -->window.fn;但是js中规定一个对象属性的属性名是不能重复的，所以

    //4.如果在预解释阶段，如果变量或者函数名已经声明过了，那么不会重新的进行声明；但是在预解释阶段需要重新的赋值
//    fn();
//    function fn(){console.log(1);}
//    fn();
//    var fn=13;
//    fn();
//    function fn(){console.log(2);}
//    fn();


//++i和i++的区别：都是在自身的值的基础上加1
    //在和其他值进行运算的时候顺序不一样
    //++i 先自己加1，拿加完后的结果和其他值进行运算
    //i++ 先拿自己当前的值和其他值运算，然后再自身加1

















</script>

</body>
</html>