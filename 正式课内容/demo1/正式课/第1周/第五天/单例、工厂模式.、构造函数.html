<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script>
    //单例模式
    // 把描述同一件事物特征的属性放在同一个分组中，避免两个事物属性的冲突->单例模式
    //在单例模式中变量名叫做命名空间->为了防止名字相同时候的冲突，我们把每一个事物都看成一个单独的个体，把描述这件事物的属性放在同一个命名空间下，以后通过不同的命名空间来区分不同的实例
    //单例模式是以后项目开发中最常用的一种实现模块化开发的模式
    //utils/tool等命名空间下封装的一般都是我们每一个模块都要使用的公用方法

    //在自己的某个方法中调用自己的某个其他方法-->this.(方法名)


    //工厂模式
    //不用像之前的单例模式一个个的写了，只需要开一个工厂，实现批量化的生产
    //把实现一个功能的代码封装到一个函数中，以后再想实现这个功能不需要重新的编写这些代码了，只需要执行这个函数即可->"类（函数）的封装"：低耦合高内聚->减少页面中的冗余代码，提高代码的重复利用率

    //面向对象（JS）：把js分成几个类，然后在每一个类中分别拿出一个具体的实例去学习研究，当这个实例研究清楚后，我们就可以认为当前类的其他实例也拥有这些知识（特点）
    //->学习面向对象的编程思想，其实就是在学习类的继承、封装、多态

    //类的多态：后台语言中的多态是一个类的多种形态，包含了：重载和重写
    //重载：多个方法，他们的方法名相同，但是参数（多少个，类型，顺序）或者返回值不同，那么我们说这就是重载
    //JS中严格意义上来说不存在重载；非严格意义来讲有一个模式和重载类似：一个方法通过传递参数的不同，方法最后处理的结果也不一样，我们也可以把它理解为重载
    //重写：JS中也有重写。子类重写父类的方法

    
    //内置类（js中天生自带的类）：Number(数字类，每一个数字都是这个类的一个实例）、String、Boolean、Null、Undefined、Object、Array、RegExp、Date、Function

    //HTMLCollection（元素集合类，通过getElementsByTagName这些方法获取到的类数组集合都是这个类的一个实例）
    
    //构造函数模式
    //在工厂模式批量生产的基础上，我们既要实现批量生产，也要实现品牌的的区分->在js中我们把品牌的区分叫做"实例识别"->“构造函数模式”
    //使用构造函数模式可以自己创建类

    //普通函数和构造函数的区别：
    //1、执行的时候
    //普通函数：方法名（）
    //构造函数：new 方法名（）
    //通过new来执行的话，此时就不是普通的函数了，而是变为了一个类（自定义类），返回的就是当前类的一个实例
    //2.运行的时候
    //当用new 来执行后，首先它还是按照普通函数执行那样，先给形成赋值，然后进行私有作用域中的预解释，最后代码从上到下执行（说明了它虽然叫做类，但是也存在普通函数的那一面）
    //但是使用new执行在普通函数执行的基础上多加了一些操作：
    //在js代码执行之前，浏览器会自动创建一个对象数据类型值（这个值就是当前类的一个实例）
    //在接下来的代码执行过程中，以创建的实例为执行的主体（this就是当前的实例），分别把需要增加的属性名和属性值赋值给当前的实例
    //代码执行完成后，浏览器会自动的把创建的实例返回到类的外面
    
    //基于构造函数模式的原型链模式
    //1.所有的函数数据类型（普通函数、类）都天生自带一个属性，叫做prototype(原型），这个属性对应的值是一个对象数据类型的值，浏览器会给这个属性值默认开辟一个新的堆内存。
    //2.在浏览器默认给这个原型属性值开辟的堆内存中，有一个天生自带的属性：constructor(构造函数)，它的属性值是当前这个类本身
    //3.每一个对象数据类型（普通的对象、数组、正则、实例、prototype值）都天生自带一个属性：__proto__（ie浏览器不允许使用），这个属性的值指向了当前这个对象所属的类的prototype

    //Object是所有对象数据类型的基类，在他的原型上没有__proto__这个属性

    //原型链模式：当我们通过"实例。属性"进行操作的时候，首先到实例的私有属性中查找，看在私有中是否存在：
    //->存在的话，接下来操作的都是自己当前实例私有的
    //->不存在的话，通过实例的__proto__找到所属类的原型上看有没有：
    //->>原型上有：接下来操作的都是原型上的
    //->>原型上没有：继续通过原型上的__proto__找到Object.prototype,看基类上是否存在：
    //-->>>基类原型上有：用的是基类上的
    //-->>>基类上没有：返回undefined

    //我们构造函数某一个属性值如果是个函数，函数中的this是谁，需要看方法执行“.”前面是谁


</script>
</body>
</html>